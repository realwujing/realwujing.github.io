# vxlan入门.md

## 什么是 vxlan

VXLAN (Virtual Extensible LAN) 是一种网络虚拟化技术，它通过在现有 IP 网络基础设施上创建虚拟的第 2 层网络来扩展传统的 VLAN 功能。

## 基本概念

1. **VXLAN 是什么**：
   - 一种 overlay 网络技术
   - 使用 MAC-in-UDP 封装
   - 将二层帧封装在 UDP 数据包中通过三层网络传输
   - VXLAN ID (VNI) 24位，可支持多达 1600 万个虚拟网络 (VLAN 只有 4096 个)

2. **主要组件**：
   - **VTEP (VXLAN Tunnel End Point)**：封装/解封装 VXLAN 流量的设备
   - **VNI (VXLAN Network Identifier)**：标识不同的虚拟网络
   - **Underlay 网络**：承载 VXLAN 流量的物理网络

## Linux 中的 VXLAN 实现

### 1. 创建 VXLAN 接口

```bash
# 基本命令
ip link add vxlan0 type vxlan id 42 dstport 4789 dev eth0 local 192.168.1.100

# 完整示例
ip link add vxlan0 type vxlan \
    id 42 \
    dstport 4789 \
    dev eth0 \
    local 192.168.1.100 \
    remote 192.168.1.101 \
    group 239.1.1.1 \
    ttl 10
```

参数说明：

- `id`: VXLAN 网络标识符 (VNI)
- `dstport`: 目标 UDP 端口 (默认 8472，但 IANA 指定 4789)
- `dev`: 底层物理接口
- `local`: 本地 VTEP IP
- `remote`: 远程 VTEP IP (点对点模式)
- `group`: 多播组地址 (多播模式)
- `ttl`: 生存时间

### 2. 启动并配置 VXLAN 接口

```bash
ip link set vxlan0 up
ip addr add 10.0.0.1/24 dev vxlan0
```

### 3. 查看 VXLAN 接口信息

```bash
ip -d link show vxlan0
```

### 4. 删除 VXLAN 接口

```bash
ip link del vxlan0
```

## VXLAN 工作模式

1. **单播模式 (Unicast)**：
   - 点对点连接
   - 需要预先知道所有对端 VTEP 地址
   - 使用 `remote` 参数指定

2. **多播模式 (Multicast)**：
   - 使用多播组自动发现 VTEP
   - 适合大规模部署
   - 使用 `group` 参数指定多播组

3. **L2/L3 网关模式**：
   - 连接 VXLAN 网络与传统网络
   - 需要特殊配置

## 高级配置

### 1. 使用桥接

```bash
# 创建网桥
ip link add br0 type bridge
ip link set br0 up

# 将 VXLAN 接口加入网桥
ip link set vxlan0 master br0
```

### 2. 静态 FDB 条目

```bash
bridge fdb append 00:11:22:33:44:55 dev vxlan0 dst 192.168.1.101
```

### 3. 使用 EVPN 控制平面

更复杂的部署可以使用 BGP EVPN 作为控制平面来自动学习 MAC 地址和 VTEP 信息。

## 内核要求

VXLAN 需要 Linux 内核支持：

- 3.7+ 版本：基本 VXLAN 支持
- 3.12+ 版本：多播支持
- 4.3+ 版本：IPv6 支持

检查内核是否支持：

```bash
modprobe vxlan
lsmod | grep vxlan
```

## 典型应用场景

1. 跨数据中心的虚拟机迁移
2. 容器网络
3. 云环境中的多租户隔离
4. 大规模网络虚拟化

## 优缺点

**优点**：

- 突破 VLAN 4096 限制
- 更好的隔离性
- 跨三层网络扩展二层
- 适合云环境和虚拟化

**缺点**：

- 封装开销 (50字节)
- 需要支持的网络设备
- 配置复杂度高于传统 VLAN

VXLAN 是现代数据中心和云环境中广泛使用的网络虚拟化技术，特别是在 Kubernetes 和 OpenStack 等平台中。

## 给出示例中的vxlan网络拓扑图

以下是示例中 VXLAN 网络的拓扑图描述及可视化表示：

---

### **VXLAN 网络拓扑图（示例）**

#### 物理网络 (Underlay)

```
+-----------------------------------------------------+
|              物理网络 (IP 网络)                      |
|   +-------------+                   +-------------+  |
|   | 主机A       |                   | 主机B       |  |
|   | eth0:       |<--- IP 连接 --->  | eth0:       |  |
|   | 192.168.1.100|                   |192.168.1.101|  |
|   +-------------+                   +-------------+  |
+-----------------------------------------------------+
```

#### 虚拟网络 (Overlay - VXLAN)

```
+-----------------------------------------------------+
|              虚拟二层网络 (VXLAN VNI 42)             |
|   +-------------+                   +-------------+  |
|   | vxlan0      |<--- VXLAN隧道 --->| vxlan0      |  |
|   | 10.0.0.1/24 |                   |10.0.0.2/24  |  |
|   +-------------+                   +-------------+  |
|   | 主机A       |                   | 主机B       |  |
|   +-------------+                   +-------------+  |
+-----------------------------------------------------+
```

---

### **关键组件说明**

1. **物理网络 (Underlay)**：
   - 主机A和主机B通过物理接口 `eth0` 在三层 IP 网络（如192.168.1.0/24）中互通。
   - 这是 VXLAN 隧道的承载网络。

2. **虚拟网络 (Overlay)**：
   - 主机A和主机B上创建了 VXLAN 接口 `vxlan0`，属于同一个虚拟网络（VNI=42）。
   - 即使主机A和主机B物理上位于不同子网，VXLAN 会让它们像在同一个二层网络中一样通信。

3. **数据流**：
   - 当主机A的 `vxlan0` 发送数据包到 `10.0.0.2`：
     1. 原始二层帧（目标MAC + IP）被封装到 UDP 数据包中。
     2. 外层 IP 头使用 Underlay 网络的地址（如 `192.168.1.100 -> 192.168.1.101`）。
     3. 通过物理网络传输到主机B后，解封装还原为原始二层帧。

---

### **拓扑图可视化**

```
+-------------------+       Underlay Network       +-------------------+
|     主机A         |------------------------------|     主机B         |
|  eth0:192.168.1.100|                              | eth0:192.168.1.101|
|                   |                              |                   |
|  +-------------+  |                              |  +-------------+  |
|  | vxlan0      |  |       VXLAN Tunnel (VNI 42)  |  | vxlan0      |  |
|  | 10.0.0.1/24 |<==============================>|  |10.0.0.2/24  |  |
|  +-------------+  |                              |  +-------------+  |
+-------------------+                              +-------------------+
```

---

### **模式说明**

1. **示例中的模式**：
   - 若命令中指定了 `remote 192.168.1.101`，则为 **单播模式**（点对点隧道）。
   - 若指定了 `group 239.1.1.1`，则为 **多播模式**（通过多播组自动发现VTEP）。

2. **扩展场景**：
   - 如需连接多个主机，可添加更多 VTEP（如主机C、主机D）。
   - 多播模式下，所有VTEP加入同一多播组即可自动建立隧道。

---

### **实际应用示例**

- **容器网络**：Kubernetes 中的 Flannel 或 Calico 使用 VXLAN 实现跨节点容器通信。
- **跨数据中心 VM 迁移**：保持虚拟机的二层网络属性不变。

## VLAN 为啥只有 4096 个？

VLAN（Virtual Local Area Network）的 ID 范围之所以限制在 **4096 个**（实际可用 4094 个），是由其技术标准和历史设计决定的，主要原因如下：

---

### **1. IEEE 802.1Q 标准的字段限制**

VLAN 的标识符（VLAN ID）在以太网帧的 **802.1Q Tag** 中占用 **12 位二进制**，其取值范围为：

- **二进制**：`000000000000` ~ `111111111111`  
- **十进制**：`0` ~ `4095`  
  - `0` 和 `4095` 为保留值（`0` 表示优先级帧，`4095` 保留未使用），因此 **实际可用 VLAN ID 为 1~4094**。

#### **802.1Q 帧结构示例**

```
| 目的MAC | 源MAC | 802.1Q Tag (4字节) | 类型/长度 | 数据... |
           ^^^^^^^^^^^^^^^^^
           其中 VLAN ID 占 12 bits（0~4095）
```

---

### **2. 历史背景与设计权衡**

- **早期网络规模需求有限**：  
  在 1998 年 IEEE 802.1Q 标准制定时，企业网络规模较小，4094 个 VLAN 被认为足够覆盖大多数场景（如部门隔离、设备分组）。
- **帧头开销优化**：  
  增加 VLAN ID 位数会扩大以太网帧头（802.1Q Tag 已占用 4 字节），可能影响网络效率（尤其是小数据包场景）。

---

### **3. 为什么不是更大？**

- **兼容性**：  
  保持与传统以太网帧的兼容性（普通以太网帧无 VLAN Tag）。
- **硬件限制**：  
  早期交换机的 TCAM（Ternary Content-Addressable Memory）容量有限，存储大量 VLAN 表项会提高成本。

---

### **4. VLAN 的替代方案**

由于 4094 个 VLAN 无法满足现代大规模网络（如云计算、多租户数据中心）的需求，催生了以下技术：

#### **(1) **VXLAN（Virtual Extensible LAN）**

- **24 位 VNI（VXLAN Network Identifier）**，支持约 **1600 万**个虚拟网络。  
- 通过 MAC-in-UDP 封装，跨三层网络扩展二层域。

#### **(2) **QinQ（IEEE 802.1ad）**

- 堆叠两层 VLAN Tag（外层 Tag 称为 S-Tag），理论上支持 `4094 x 4094` 个网络，但管理复杂。

#### **(3) **NVGRE、GRE 等 Overlay 技术**  

  其他隧道协议也可突破 VLAN 数量限制。

---

### **5. 为什么 VXLAN 能突破限制？**

- **封装方式不同**：  
  VXLAN 将整个二层帧封装在 UDP 中，无需依赖传统以太网帧头。  
- **现代硬件支持**：  
  新一代交换机/网卡支持 VXLAN 硬件卸载（如 VTEP），降低性能开销。

---

### **总结**

- **VLAN 的 4096 限制**源于 802.1Q 标准的 12 位字段设计，是历史与技术的权衡结果。  
- **大规模虚拟化网络**需依赖 VXLAN 等 Overlay 技术，通过扩展标识符位数（如 24 位 VNI）解决这一问题。  
- **关键区别**：  

  | 技术   | 标识符位数 | 最大网络数  | 适用场景               |  
  |--------|------------|-------------|-----------------------|  
  | VLAN   | 12-bit     | 4094        | 传统企业网络           |  
  | VXLAN  | 24-bit     | 16,777,214  | 云数据中心、SDN        |

## vxlan.ko与openvswitch.ko的区别

在 Linux 网络虚拟化中，`vxlan.ko` 和 `openvswitch.ko` 都支持 VXLAN，但它们的实现方式、架构和适用场景有显著区别。以下是两者的详细对比：

---

### **1. 内核模块基础**

| **特性**               | **`vxlan.ko`**                          | **`openvswitch.ko`**                   |
|------------------------|----------------------------------------|----------------------------------------|
| **所属项目**           | Linux 内核原生支持                      | Open vSwitch (OVS) 用户态+内核态方案    |
| **依赖关系**           | 纯内核模块，无需额外组件                | 需配合用户态守护进程 `ovs-vswitchd`    |
| **定位**               | 轻量级 VXLAN 实现                       | 功能丰富的虚拟交换机，支持多种隧道协议 |

---

### **2. VXLAN 实现方式**

#### **(1) `vxlan.ko`**

- **封装/解封装**：  
  由内核直接处理 VXLAN 的 MAC-in-UDP 封装，性能较高。
- **控制平面**：  
  依赖静态配置（如 `ip link` 命令）或简单多播，无高级控制协议（如 EVPN）。
- **典型用途**：  
  点对点 VXLAN 隧道、简单的 Overlay 网络。

#### **(2) `openvswitch.ko`**

- **封装/解封装**：  
  OVS 内核模块处理封装，但流表规则由用户态 `ovs-vswitchd` 下发，灵活性更高。
- **控制平面**：  
  支持动态协议（如 OVSDB、OpenFlow、BGP EVPN），适合 SDN 场景。
- **典型用途**：  
  复杂虚拟化网络（如 OpenStack、Kubernetes）、多租户隔离、分布式网关。

---

### **3. 功能对比**

| **功能**               | **`vxlan.ko`**                          | **`openvswitch.ko`**                   |
|------------------------|----------------------------------------|----------------------------------------|
| **VXLAN 支持**         | 是（基础封装）                          | 是（支持更复杂的流表规则）              |
| **多播/单播**          | 支持                                   | 支持                                   |
| **控制协议**           | 仅静态配置                             | 支持 EVPN、OpenFlow、OVSDB             |
| **流表规则**           | 无                                     | 支持复杂匹配和动作（如 NAT、QoS）       |
| **性能**               | 更高（纯内核处理）                      | 稍低（需用户态交互）                   |
| **适用场景**           | 简单 Overlay 网络                       | 云平台、SDN、多租户网络                |

---

### **4. 配置示例**

#### **(1) `vxlan.ko` 配置（静态单播）**

```bash
# 创建 VXLAN 接口
ip link add vxlan0 type vxlan \
    id 42 \
    dstport 4789 \
    dev eth0 \
    local 192.168.1.100 \
    remote 192.168.1.101

# 启动并分配 IP
ip link set vxlan0 up
ip addr add 10.0.0.1/24 dev vxlan0
```

#### **(2) `openvswitch.ko` 配置（OVS + VXLAN）**

```bash
# 创建 OVS 网桥并添加 VXLAN 端口
ovs-vsctl add-br ovs-br0
ovs-vsctl add-port ovs-br0 vxlan0 \
    -- set interface vxlan0 type=vxlan \
    options:remote_ip=192.168.1.101 \
    options:key=42

# 分配 IP（可选）
ip addr add 10.0.0.1/24 dev ovs-br0
```

---

### **5. 性能与扩展性**

- **`vxlan.ko`**：  
  - **优势**：低延迟、高吞吐（内核直接处理）。  
  - **劣势**：缺乏动态控制能力，扩展性差（需手动管理 VTEP）。
- **`openvswitch.ko`**：  
  - **优势**：支持自动化（如 EVPN）、策略灵活（流表）。  
  - **劣势**：用户态-内核态交互可能引入微秒级延迟。

---

### **6. 如何选择？**

- **使用 `vxlan.ko` 的场景**：  
  - 需要简单、高性能的 VXLAN 隧道（如容器网络）。  
  - 无需复杂控制平面（如 Calico 的某些模式）。
- **使用 `openvswitch.ko` 的场景**：  
  - 云平台（OpenStack、Kubernetes）。  
  - 需要 EVPN、分布式网关或精细流表控制。

---

### **总结**

- **`vxlan.ko`** 是内核原生方案，适合轻量级 VXLAN。  
- **`openvswitch.ko`** 是 OVS 的一部分，适合复杂虚拟化网络。  
- 两者可共存：OVS 内部也可能调用 `vxlan.ko` 进行封装，但管理方式不同。
